import re, { useMemo as Te, useEffect as Ae, Fragment as Ft, useState as Ct, useRef as it, useCallback as Ke } from "react";
import { Button as zt, Modal as Kt, Checkbox as Ht, Input as Bt, Table as Ut } from "antd";
var $e = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Ge = {}, Wt = {
  get exports() {
    return Ge;
  },
  set exports(e) {
    Ge = e;
  }
};
/* @license
Papa Parse
v5.4.1
https://github.com/mholt/PapaParse
License: MIT
*/
(function(e, t) {
  (function(r, n) {
    e.exports = n();
  })($e, function r() {
    var n = typeof self < "u" ? self : typeof window < "u" ? window : n !== void 0 ? n : {}, a = !n.document && !!n.postMessage, c = n.IS_PAPA_WORKER || !1, h = {}, l = 0, o = { parse: function(s, i) {
      var u = (i = i || {}).dynamicTyping || !1;
      if (v(u) && (i.dynamicTypingFunction = u, u = {}), i.dynamicTyping = u, i.transform = !!v(i.transform) && i.transform, i.worker && o.WORKERS_SUPPORTED) {
        var g = function() {
          if (!o.WORKERS_SUPPORTED)
            return !1;
          var k = (K = n.URL || n.webkitURL || null, N = r.toString(), o.BLOB_URL || (o.BLOB_URL = K.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", N, ")();"], { type: "text/javascript" })))), w = new n.Worker(k), K, N;
          return w.onmessage = G, w.id = l++, h[w.id] = w;
        }();
        return g.userStep = i.step, g.userChunk = i.chunk, g.userComplete = i.complete, g.userError = i.error, i.step = v(i.step), i.chunk = v(i.chunk), i.complete = v(i.complete), i.error = v(i.error), delete i.worker, void g.postMessage({ input: s, config: i, workerId: g.id });
      }
      var _ = null;
      return o.NODE_STREAM_INPUT, typeof s == "string" ? (s = function(k) {
        return k.charCodeAt(0) === 65279 ? k.slice(1) : k;
      }(s), _ = i.download ? new p(i) : new x(i)) : s.readable === !0 && v(s.read) && v(s.on) ? _ = new O(i) : (n.File && s instanceof File || s instanceof Object) && (_ = new E(i)), _.stream(s);
    }, unparse: function(s, i) {
      var u = !1, g = !0, _ = ",", k = `\r
`, w = '"', K = w + w, N = !1, y = null, U = !1;
      (function() {
        if (typeof i == "object") {
          if (typeof i.delimiter != "string" || o.BAD_DELIMITERS.filter(function(m) {
            return i.delimiter.indexOf(m) !== -1;
          }).length || (_ = i.delimiter), (typeof i.quotes == "boolean" || typeof i.quotes == "function" || Array.isArray(i.quotes)) && (u = i.quotes), typeof i.skipEmptyLines != "boolean" && typeof i.skipEmptyLines != "string" || (N = i.skipEmptyLines), typeof i.newline == "string" && (k = i.newline), typeof i.quoteChar == "string" && (w = i.quoteChar), typeof i.header == "boolean" && (g = i.header), Array.isArray(i.columns)) {
            if (i.columns.length === 0)
              throw new Error("Option columns is empty");
            y = i.columns;
          }
          i.escapeChar !== void 0 && (K = i.escapeChar + w), (typeof i.escapeFormulae == "boolean" || i.escapeFormulae instanceof RegExp) && (U = i.escapeFormulae instanceof RegExp ? i.escapeFormulae : /^[=+\-@\t\r].*$/);
        }
      })();
      var C = new RegExp(T(w), "g");
      if (typeof s == "string" && (s = JSON.parse(s)), Array.isArray(s)) {
        if (!s.length || Array.isArray(s[0]))
          return ce(null, s, N);
        if (typeof s[0] == "object")
          return ce(y || Object.keys(s[0]), s, N);
      } else if (typeof s == "object")
        return typeof s.data == "string" && (s.data = JSON.parse(s.data)), Array.isArray(s.data) && (s.fields || (s.fields = s.meta && s.meta.fields || y), s.fields || (s.fields = Array.isArray(s.data[0]) ? s.fields : typeof s.data[0] == "object" ? Object.keys(s.data[0]) : []), Array.isArray(s.data[0]) || typeof s.data[0] == "object" || (s.data = [s.data])), ce(s.fields || [], s.data || [], N);
      throw new Error("Unable to serialize unrecognized input");
      function ce(m, P, ee) {
        var H = "";
        typeof m == "string" && (m = JSON.parse(m)), typeof P == "string" && (P = JSON.parse(P));
        var X = Array.isArray(m) && 0 < m.length, V = !Array.isArray(P[0]);
        if (X && g) {
          for (var Y = 0; Y < m.length; Y++)
            0 < Y && (H += _), H += Z(m[Y], Y);
          0 < P.length && (H += k);
        }
        for (var b = 0; b < P.length; b++) {
          var S = X ? m.length : P[b].length, F = !1, J = X ? Object.keys(P[b]).length === 0 : P[b].length === 0;
          if (ee && !X && (F = ee === "greedy" ? P[b].join("").trim() === "" : P[b].length === 1 && P[b][0].length === 0), ee === "greedy" && X) {
            for (var L = [], te = 0; te < S; te++) {
              var W = V ? m[te] : te;
              L.push(P[b][W]);
            }
            F = L.join("").trim() === "";
          }
          if (!F) {
            for (var D = 0; D < S; D++) {
              0 < D && !J && (H += _);
              var he = X && V ? m[D] : D;
              H += Z(P[b][he], D);
            }
            b < P.length - 1 && (!ee || 0 < S && !J) && (H += k);
          }
        }
        return H;
      }
      function Z(m, P) {
        if (m == null)
          return "";
        if (m.constructor === Date)
          return JSON.stringify(m).slice(1, 25);
        var ee = !1;
        U && typeof m == "string" && U.test(m) && (m = "'" + m, ee = !0);
        var H = m.toString().replace(C, K);
        return (ee = ee || u === !0 || typeof u == "function" && u(m, P) || Array.isArray(u) && u[P] || function(X, V) {
          for (var Y = 0; Y < V.length; Y++)
            if (-1 < X.indexOf(V[Y]))
              return !0;
          return !1;
        }(H, o.BAD_DELIMITERS) || -1 < H.indexOf(_) || H.charAt(0) === " " || H.charAt(H.length - 1) === " ") ? w + H + w : H;
      }
    } };
    if (o.RECORD_SEP = String.fromCharCode(30), o.UNIT_SEP = String.fromCharCode(31), o.BYTE_ORDER_MARK = "\uFEFF", o.BAD_DELIMITERS = ["\r", `
`, '"', o.BYTE_ORDER_MARK], o.WORKERS_SUPPORTED = !a && !!n.Worker, o.NODE_STREAM_INPUT = 1, o.LocalChunkSize = 10485760, o.RemoteChunkSize = 5242880, o.DefaultDelimiter = ",", o.Parser = M, o.ParserHandle = A, o.NetworkStreamer = p, o.FileStreamer = E, o.StringStreamer = x, o.ReadableStreamStreamer = O, n.jQuery) {
      var f = n.jQuery;
      f.fn.parse = function(s) {
        var i = s.config || {}, u = [];
        return this.each(function(k) {
          if (!(f(this).prop("tagName").toUpperCase() === "INPUT" && f(this).attr("type").toLowerCase() === "file" && n.FileReader) || !this.files || this.files.length === 0)
            return !0;
          for (var w = 0; w < this.files.length; w++)
            u.push({ file: this.files[w], inputElem: this, instanceConfig: f.extend({}, i) });
        }), g(), this;
        function g() {
          if (u.length !== 0) {
            var k, w, K, N, y = u[0];
            if (v(s.before)) {
              var U = s.before(y.file, y.inputElem);
              if (typeof U == "object") {
                if (U.action === "abort")
                  return k = "AbortError", w = y.file, K = y.inputElem, N = U.reason, void (v(s.error) && s.error({ name: k }, w, K, N));
                if (U.action === "skip")
                  return void _();
                typeof U.config == "object" && (y.instanceConfig = f.extend(y.instanceConfig, U.config));
              } else if (U === "skip")
                return void _();
            }
            var C = y.instanceConfig.complete;
            y.instanceConfig.complete = function(ce) {
              v(C) && C(ce, y.file, y.inputElem), _();
            }, o.parse(y.file, y.instanceConfig);
          } else
            v(s.complete) && s.complete();
        }
        function _() {
          u.splice(0, 1), g();
        }
      };
    }
    function d(s) {
      this._handle = null, this._finished = !1, this._completed = !1, this._halted = !1, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = !0, this._completeResults = { data: [], errors: [], meta: {} }, function(i) {
        var u = Q(i);
        u.chunkSize = parseInt(u.chunkSize), i.step || i.chunk || (u.chunkSize = null), this._handle = new A(u), (this._handle.streamer = this)._config = u;
      }.call(this, s), this.parseChunk = function(i, u) {
        if (this.isFirstChunk && v(this._config.beforeFirstChunk)) {
          var g = this._config.beforeFirstChunk(i);
          g !== void 0 && (i = g);
        }
        this.isFirstChunk = !1, this._halted = !1;
        var _ = this._partialLine + i;
        this._partialLine = "";
        var k = this._handle.parse(_, this._baseIndex, !this._finished);
        if (!this._handle.paused() && !this._handle.aborted()) {
          var w = k.meta.cursor;
          this._finished || (this._partialLine = _.substring(w - this._baseIndex), this._baseIndex = w), k && k.data && (this._rowCount += k.data.length);
          var K = this._finished || this._config.preview && this._rowCount >= this._config.preview;
          if (c)
            n.postMessage({ results: k, workerId: o.WORKER_ID, finished: K });
          else if (v(this._config.chunk) && !u) {
            if (this._config.chunk(k, this._handle), this._handle.paused() || this._handle.aborted())
              return void (this._halted = !0);
            k = void 0, this._completeResults = void 0;
          }
          return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(k.data), this._completeResults.errors = this._completeResults.errors.concat(k.errors), this._completeResults.meta = k.meta), this._completed || !K || !v(this._config.complete) || k && k.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = !0), K || k && k.meta.paused || this._nextChunk(), k;
        }
        this._halted = !0;
      }, this._sendError = function(i) {
        v(this._config.error) ? this._config.error(i) : c && this._config.error && n.postMessage({ workerId: o.WORKER_ID, error: i, finished: !1 });
      };
    }
    function p(s) {
      var i;
      (s = s || {}).chunkSize || (s.chunkSize = o.RemoteChunkSize), d.call(this, s), this._nextChunk = a ? function() {
        this._readChunk(), this._chunkLoaded();
      } : function() {
        this._readChunk();
      }, this.stream = function(u) {
        this._input = u, this._nextChunk();
      }, this._readChunk = function() {
        if (this._finished)
          this._chunkLoaded();
        else {
          if (i = new XMLHttpRequest(), this._config.withCredentials && (i.withCredentials = this._config.withCredentials), a || (i.onload = $(this._chunkLoaded, this), i.onerror = $(this._chunkError, this)), i.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !a), this._config.downloadRequestHeaders) {
            var u = this._config.downloadRequestHeaders;
            for (var g in u)
              i.setRequestHeader(g, u[g]);
          }
          if (this._config.chunkSize) {
            var _ = this._start + this._config.chunkSize - 1;
            i.setRequestHeader("Range", "bytes=" + this._start + "-" + _);
          }
          try {
            i.send(this._config.downloadRequestBody);
          } catch (k) {
            this._chunkError(k.message);
          }
          a && i.status === 0 && this._chunkError();
        }
      }, this._chunkLoaded = function() {
        i.readyState === 4 && (i.status < 200 || 400 <= i.status ? this._chunkError() : (this._start += this._config.chunkSize ? this._config.chunkSize : i.responseText.length, this._finished = !this._config.chunkSize || this._start >= function(u) {
          var g = u.getResponseHeader("Content-Range");
          return g === null ? -1 : parseInt(g.substring(g.lastIndexOf("/") + 1));
        }(i), this.parseChunk(i.responseText)));
      }, this._chunkError = function(u) {
        var g = i.statusText || u;
        this._sendError(new Error(g));
      };
    }
    function E(s) {
      var i, u;
      (s = s || {}).chunkSize || (s.chunkSize = o.LocalChunkSize), d.call(this, s);
      var g = typeof FileReader < "u";
      this.stream = function(_) {
        this._input = _, u = _.slice || _.webkitSlice || _.mozSlice, g ? ((i = new FileReader()).onload = $(this._chunkLoaded, this), i.onerror = $(this._chunkError, this)) : i = new FileReaderSync(), this._nextChunk();
      }, this._nextChunk = function() {
        this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
      }, this._readChunk = function() {
        var _ = this._input;
        if (this._config.chunkSize) {
          var k = Math.min(this._start + this._config.chunkSize, this._input.size);
          _ = u.call(_, this._start, k);
        }
        var w = i.readAsText(_, this._config.encoding);
        g || this._chunkLoaded({ target: { result: w } });
      }, this._chunkLoaded = function(_) {
        this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(_.target.result);
      }, this._chunkError = function() {
        this._sendError(i.error);
      };
    }
    function x(s) {
      var i;
      d.call(this, s = s || {}), this.stream = function(u) {
        return i = u, this._nextChunk();
      }, this._nextChunk = function() {
        if (!this._finished) {
          var u, g = this._config.chunkSize;
          return g ? (u = i.substring(0, g), i = i.substring(g)) : (u = i, i = ""), this._finished = !i, this.parseChunk(u);
        }
      };
    }
    function O(s) {
      d.call(this, s = s || {});
      var i = [], u = !0, g = !1;
      this.pause = function() {
        d.prototype.pause.apply(this, arguments), this._input.pause();
      }, this.resume = function() {
        d.prototype.resume.apply(this, arguments), this._input.resume();
      }, this.stream = function(_) {
        this._input = _, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
      }, this._checkIsFinished = function() {
        g && i.length === 1 && (this._finished = !0);
      }, this._nextChunk = function() {
        this._checkIsFinished(), i.length ? this.parseChunk(i.shift()) : u = !0;
      }, this._streamData = $(function(_) {
        try {
          i.push(typeof _ == "string" ? _ : _.toString(this._config.encoding)), u && (u = !1, this._checkIsFinished(), this.parseChunk(i.shift()));
        } catch (k) {
          this._streamError(k);
        }
      }, this), this._streamError = $(function(_) {
        this._streamCleanUp(), this._sendError(_);
      }, this), this._streamEnd = $(function() {
        this._streamCleanUp(), g = !0, this._streamData("");
      }, this), this._streamCleanUp = $(function() {
        this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
      }, this);
    }
    function A(s) {
      var i, u, g, _ = Math.pow(2, 53), k = -_, w = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, K = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, N = this, y = 0, U = 0, C = !1, ce = !1, Z = [], m = { data: [], errors: [], meta: {} };
      if (v(s.step)) {
        var P = s.step;
        s.step = function(b) {
          if (m = b, X())
            H();
          else {
            if (H(), m.data.length === 0)
              return;
            y += b.data.length, s.preview && y > s.preview ? u.abort() : (m.data = m.data[0], P(m, N));
          }
        };
      }
      function ee(b) {
        return s.skipEmptyLines === "greedy" ? b.join("").trim() === "" : b.length === 1 && b[0].length === 0;
      }
      function H() {
        return m && g && (Y("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + o.DefaultDelimiter + "'"), g = !1), s.skipEmptyLines && (m.data = m.data.filter(function(b) {
          return !ee(b);
        })), X() && function() {
          if (!m)
            return;
          function b(F, J) {
            v(s.transformHeader) && (F = s.transformHeader(F, J)), Z.push(F);
          }
          if (Array.isArray(m.data[0])) {
            for (var S = 0; X() && S < m.data.length; S++)
              m.data[S].forEach(b);
            m.data.splice(0, 1);
          } else
            m.data.forEach(b);
        }(), function() {
          if (!m || !s.header && !s.dynamicTyping && !s.transform)
            return m;
          function b(F, J) {
            var L, te = s.header ? {} : [];
            for (L = 0; L < F.length; L++) {
              var W = L, D = F[L];
              s.header && (W = L >= Z.length ? "__parsed_extra" : Z[L]), s.transform && (D = s.transform(D, W)), D = V(W, D), W === "__parsed_extra" ? (te[W] = te[W] || [], te[W].push(D)) : te[W] = D;
            }
            return s.header && (L > Z.length ? Y("FieldMismatch", "TooManyFields", "Too many fields: expected " + Z.length + " fields but parsed " + L, U + J) : L < Z.length && Y("FieldMismatch", "TooFewFields", "Too few fields: expected " + Z.length + " fields but parsed " + L, U + J)), te;
          }
          var S = 1;
          return !m.data.length || Array.isArray(m.data[0]) ? (m.data = m.data.map(b), S = m.data.length) : m.data = b(m.data, 0), s.header && m.meta && (m.meta.fields = Z), U += S, m;
        }();
      }
      function X() {
        return s.header && Z.length === 0;
      }
      function V(b, S) {
        return F = b, s.dynamicTypingFunction && s.dynamicTyping[F] === void 0 && (s.dynamicTyping[F] = s.dynamicTypingFunction(F)), (s.dynamicTyping[F] || s.dynamicTyping) === !0 ? S === "true" || S === "TRUE" || S !== "false" && S !== "FALSE" && (function(J) {
          if (w.test(J)) {
            var L = parseFloat(J);
            if (k < L && L < _)
              return !0;
          }
          return !1;
        }(S) ? parseFloat(S) : K.test(S) ? new Date(S) : S === "" ? null : S) : S;
        var F;
      }
      function Y(b, S, F, J) {
        var L = { type: b, code: S, message: F };
        J !== void 0 && (L.row = J), m.errors.push(L);
      }
      this.parse = function(b, S, F) {
        var J = s.quoteChar || '"';
        if (s.newline || (s.newline = function(W, D) {
          W = W.substring(0, 1048576);
          var he = new RegExp(T(D) + "([^]*?)" + T(D), "gm"), ie = (W = W.replace(he, "")).split("\r"), le = W.split(`
`), fe = 1 < le.length && le[0].length < ie[0].length;
          if (ie.length === 1 || fe)
            return `
`;
          for (var se = 0, z = 0; z < ie.length; z++)
            ie[z][0] === `
` && se++;
          return se >= ie.length / 2 ? `\r
` : "\r";
        }(b, J)), g = !1, s.delimiter)
          v(s.delimiter) && (s.delimiter = s.delimiter(b), m.meta.delimiter = s.delimiter);
        else {
          var L = function(W, D, he, ie, le) {
            var fe, se, z, q;
            le = le || [",", "	", "|", ";", o.RECORD_SEP, o.UNIT_SEP];
            for (var ve = 0; ve < le.length; ve++) {
              var R = le[ve], Ce = 0, de = 0, be = 0;
              z = void 0;
              for (var ge = new M({ comments: ie, delimiter: R, newline: D, preview: 10 }).parse(W), _e = 0; _e < ge.data.length; _e++)
                if (he && ee(ge.data[_e]))
                  be++;
                else {
                  var me = ge.data[_e].length;
                  de += me, z !== void 0 ? 0 < me && (Ce += Math.abs(me - z), z = me) : z = me;
                }
              0 < ge.data.length && (de /= ge.data.length - be), (se === void 0 || Ce <= se) && (q === void 0 || q < de) && 1.99 < de && (se = Ce, fe = R, q = de);
            }
            return { successful: !!(s.delimiter = fe), bestDelimiter: fe };
          }(b, s.newline, s.skipEmptyLines, s.comments, s.delimitersToGuess);
          L.successful ? s.delimiter = L.bestDelimiter : (g = !0, s.delimiter = o.DefaultDelimiter), m.meta.delimiter = s.delimiter;
        }
        var te = Q(s);
        return s.preview && s.header && te.preview++, i = b, u = new M(te), m = u.parse(i, S, F), H(), C ? { meta: { paused: !0 } } : m || { meta: { paused: !1 } };
      }, this.paused = function() {
        return C;
      }, this.pause = function() {
        C = !0, u.abort(), i = v(s.chunk) ? "" : i.substring(u.getCharIndex());
      }, this.resume = function() {
        N.streamer._halted ? (C = !1, N.streamer.parseChunk(i, !0)) : setTimeout(N.resume, 3);
      }, this.aborted = function() {
        return ce;
      }, this.abort = function() {
        ce = !0, u.abort(), m.meta.aborted = !0, v(s.complete) && s.complete(m), i = "";
      };
    }
    function T(s) {
      return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function M(s) {
      var i, u = (s = s || {}).delimiter, g = s.newline, _ = s.comments, k = s.step, w = s.preview, K = s.fastMode, N = i = s.quoteChar === void 0 || s.quoteChar === null ? '"' : s.quoteChar;
      if (s.escapeChar !== void 0 && (N = s.escapeChar), (typeof u != "string" || -1 < o.BAD_DELIMITERS.indexOf(u)) && (u = ","), _ === u)
        throw new Error("Comment character same as delimiter");
      _ === !0 ? _ = "#" : (typeof _ != "string" || -1 < o.BAD_DELIMITERS.indexOf(_)) && (_ = !1), g !== `
` && g !== "\r" && g !== `\r
` && (g = `
`);
      var y = 0, U = !1;
      this.parse = function(C, ce, Z) {
        if (typeof C != "string")
          throw new Error("Input must be a string");
        var m = C.length, P = u.length, ee = g.length, H = _.length, X = v(k), V = [], Y = [], b = [], S = y = 0;
        if (!C)
          return ae();
        if (s.header && !ce) {
          var F = C.split(g)[0].split(u), J = [], L = {}, te = !1;
          for (var W in F) {
            var D = F[W];
            v(s.transformHeader) && (D = s.transformHeader(D, W));
            var he = D, ie = L[D] || 0;
            for (0 < ie && (te = !0, he = D + "_" + ie), L[D] = ie + 1; J.includes(he); )
              he = he + "_" + ie;
            J.push(he);
          }
          if (te) {
            var le = C.split(g);
            le[0] = J.join(u), C = le.join(g);
          }
        }
        if (K || K !== !1 && C.indexOf(i) === -1) {
          for (var fe = C.split(g), se = 0; se < fe.length; se++) {
            if (b = fe[se], y += b.length, se !== fe.length - 1)
              y += g.length;
            else if (Z)
              return ae();
            if (!_ || b.substring(0, H) !== _) {
              if (X) {
                if (V = [], be(b.split(u)), Me(), U)
                  return ae();
              } else
                be(b.split(u));
              if (w && w <= se)
                return V = V.slice(0, w), ae(!0);
            }
          }
          return ae();
        }
        for (var z = C.indexOf(u, y), q = C.indexOf(g, y), ve = new RegExp(T(N) + T(i), "g"), R = C.indexOf(i, y); ; )
          if (C[y] !== i)
            if (_ && b.length === 0 && C.substring(y, y + H) === _) {
              if (q === -1)
                return ae();
              y = q + ee, q = C.indexOf(g, y), z = C.indexOf(u, y);
            } else if (z !== -1 && (z < q || q === -1))
              b.push(C.substring(y, z)), y = z + P, z = C.indexOf(u, y);
            else {
              if (q === -1)
                break;
              if (b.push(C.substring(y, q)), me(q + ee), X && (Me(), U))
                return ae();
              if (w && V.length >= w)
                return ae(!0);
            }
          else
            for (R = y, y++; ; ) {
              if ((R = C.indexOf(i, R + 1)) === -1)
                return Z || Y.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: V.length, index: y }), _e();
              if (R === m - 1)
                return _e(C.substring(y, R).replace(ve, i));
              if (i !== N || C[R + 1] !== N) {
                if (i === N || R === 0 || C[R - 1] !== N) {
                  z !== -1 && z < R + 1 && (z = C.indexOf(u, R + 1)), q !== -1 && q < R + 1 && (q = C.indexOf(g, R + 1));
                  var Ce = ge(q === -1 ? z : Math.min(z, q));
                  if (C.substr(R + 1 + Ce, P) === u) {
                    b.push(C.substring(y, R).replace(ve, i)), C[y = R + 1 + Ce + P] !== i && (R = C.indexOf(i, y)), z = C.indexOf(u, y), q = C.indexOf(g, y);
                    break;
                  }
                  var de = ge(q);
                  if (C.substring(R + 1 + de, R + 1 + de + ee) === g) {
                    if (b.push(C.substring(y, R).replace(ve, i)), me(R + 1 + de + ee), z = C.indexOf(u, y), R = C.indexOf(i, y), X && (Me(), U))
                      return ae();
                    if (w && V.length >= w)
                      return ae(!0);
                    break;
                  }
                  Y.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: V.length, index: y }), R++;
                }
              } else
                R++;
            }
        return _e();
        function be(oe) {
          V.push(oe), S = y;
        }
        function ge(oe) {
          var nt = 0;
          if (oe !== -1) {
            var ze = C.substring(R + 1, oe);
            ze && ze.trim() === "" && (nt = ze.length);
          }
          return nt;
        }
        function _e(oe) {
          return Z || (oe === void 0 && (oe = C.substring(y)), b.push(oe), y = m, be(b), X && Me()), ae();
        }
        function me(oe) {
          y = oe, be(b), b = [], q = C.indexOf(g, y);
        }
        function ae(oe) {
          return { data: V, errors: Y, meta: { delimiter: u, linebreak: g, aborted: U, truncated: !!oe, cursor: S + (ce || 0) } };
        }
        function Me() {
          k(ae()), V = [], Y = [];
        }
      }, this.abort = function() {
        U = !0;
      }, this.getCharIndex = function() {
        return y;
      };
    }
    function G(s) {
      var i = s.data, u = h[i.workerId], g = !1;
      if (i.error)
        u.userError(i.error, i.file);
      else if (i.results && i.results.data) {
        var _ = { abort: function() {
          g = !0, j(i.workerId, { data: [], errors: [], meta: { aborted: !0 } });
        }, pause: B, resume: B };
        if (v(u.userStep)) {
          for (var k = 0; k < i.results.data.length && (u.userStep({ data: i.results.data[k], errors: i.results.errors, meta: i.results.meta }, _), !g); k++)
            ;
          delete i.results;
        } else
          v(u.userChunk) && (u.userChunk(i.results, _, i.file), delete i.results);
      }
      i.finished && !g && j(i.workerId, i.results);
    }
    function j(s, i) {
      var u = h[s];
      v(u.userComplete) && u.userComplete(i), u.terminate(), delete h[s];
    }
    function B() {
      throw new Error("Not implemented.");
    }
    function Q(s) {
      if (typeof s != "object" || s === null)
        return s;
      var i = Array.isArray(s) ? [] : {};
      for (var u in s)
        i[u] = Q(s[u]);
      return i;
    }
    function $(s, i) {
      return function() {
        s.apply(i, arguments);
      };
    }
    function v(s) {
      return typeof s == "function";
    }
    return c && (n.onmessage = function(s) {
      var i = s.data;
      if (o.WORKER_ID === void 0 && i && (o.WORKER_ID = i.workerId), typeof i.input == "string")
        n.postMessage({ workerId: o.WORKER_ID, results: o.parse(i.input, i.config), finished: !0 });
      else if (n.File && i.input instanceof File || i.input instanceof Object) {
        var u = o.parse(i.input, i.config);
        u && n.postMessage({ workerId: o.WORKER_ID, results: u, finished: !0 });
      }
    }), (p.prototype = Object.create(d.prototype)).constructor = p, (E.prototype = Object.create(d.prototype)).constructor = E, (x.prototype = Object.create(x.prototype)).constructor = x, (O.prototype = Object.create(d.prototype)).constructor = O, o;
  });
})(Wt);
var Gt = Array.isArray, Ze = Gt, qt = typeof $e == "object" && $e && $e.Object === Object && $e, Qt = qt, Jt = Qt, Vt = typeof self == "object" && self && self.Object === Object && self, Yt = Jt || Vt || Function("return this")(), Le = Yt, Xt = Le, Zt = Xt.Symbol, et = Zt, st = et, xt = Object.prototype, er = xt.hasOwnProperty, tr = xt.toString, Oe = st ? st.toStringTag : void 0;
function rr(e) {
  var t = er.call(e, Oe), r = e[Oe];
  try {
    e[Oe] = void 0;
    var n = !0;
  } catch {
  }
  var a = tr.call(e);
  return n && (t ? e[Oe] = r : delete e[Oe]), a;
}
var nr = rr, ir = Object.prototype, sr = ir.toString;
function ar(e) {
  return sr.call(e);
}
var or = ar, at = et, cr = nr, hr = or, lr = "[object Null]", ur = "[object Undefined]", ot = at ? at.toStringTag : void 0;
function fr(e) {
  return e == null ? e === void 0 ? ur : lr : ot && ot in Object(e) ? cr(e) : hr(e);
}
var wt = fr;
function dr(e) {
  return e != null && typeof e == "object";
}
var pr = dr, gr = wt, _r = pr, mr = "[object Symbol]";
function yr(e) {
  return typeof e == "symbol" || _r(e) && gr(e) == mr;
}
var je = yr, vr = Ze, br = je, Er = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Cr = /^\w*$/;
function xr(e, t) {
  if (vr(e))
    return !1;
  var r = typeof e;
  return r == "number" || r == "symbol" || r == "boolean" || e == null || br(e) ? !0 : Cr.test(e) || !Er.test(e) || t != null && e in Object(t);
}
var wr = xr;
function kr(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var Ne = kr, Ir = wt, Or = Ne, $r = "[object AsyncFunction]", Mr = "[object Function]", Sr = "[object GeneratorFunction]", Tr = "[object Proxy]";
function Ar(e) {
  if (!Or(e))
    return !1;
  var t = Ir(e);
  return t == Mr || t == Sr || t == $r || t == Tr;
}
var Rr = Ar, Lr = Le, jr = Lr["__core-js_shared__"], Nr = jr, He = Nr, ct = function() {
  var e = /[^.]+$/.exec(He && He.keys && He.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function Dr(e) {
  return !!ct && ct in e;
}
var Pr = Dr, Fr = Function.prototype, zr = Fr.toString;
function Kr(e) {
  if (e != null) {
    try {
      return zr.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var Hr = Kr, Br = Rr, Ur = Pr, Wr = Ne, Gr = Hr, qr = /[\\^$.*+?()[\]{}|]/g, Qr = /^\[object .+?Constructor\]$/, Jr = Function.prototype, Vr = Object.prototype, Yr = Jr.toString, Xr = Vr.hasOwnProperty, Zr = RegExp(
  "^" + Yr.call(Xr).replace(qr, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function en(e) {
  if (!Wr(e) || Ur(e))
    return !1;
  var t = Br(e) ? Zr : Qr;
  return t.test(Gr(e));
}
var tn = en;
function rn(e, t) {
  return e == null ? void 0 : e[t];
}
var nn = rn, sn = tn, an = nn;
function on(e, t) {
  var r = an(e, t);
  return sn(r) ? r : void 0;
}
var kt = on, cn = kt, hn = cn(Object, "create"), De = hn, ht = De;
function ln() {
  this.__data__ = ht ? ht(null) : {}, this.size = 0;
}
var un = ln;
function fn(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var dn = fn, pn = De, gn = "__lodash_hash_undefined__", _n = Object.prototype, mn = _n.hasOwnProperty;
function yn(e) {
  var t = this.__data__;
  if (pn) {
    var r = t[e];
    return r === gn ? void 0 : r;
  }
  return mn.call(t, e) ? t[e] : void 0;
}
var vn = yn, bn = De, En = Object.prototype, Cn = En.hasOwnProperty;
function xn(e) {
  var t = this.__data__;
  return bn ? t[e] !== void 0 : Cn.call(t, e);
}
var wn = xn, kn = De, In = "__lodash_hash_undefined__";
function On(e, t) {
  var r = this.__data__;
  return this.size += this.has(e) ? 0 : 1, r[e] = kn && t === void 0 ? In : t, this;
}
var $n = On, Mn = un, Sn = dn, Tn = vn, An = wn, Rn = $n;
function xe(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
xe.prototype.clear = Mn;
xe.prototype.delete = Sn;
xe.prototype.get = Tn;
xe.prototype.has = An;
xe.prototype.set = Rn;
var Ln = xe;
function jn() {
  this.__data__ = [], this.size = 0;
}
var Nn = jn;
function Dn(e, t) {
  return e === t || e !== e && t !== t;
}
var Pn = Dn, Fn = Pn;
function zn(e, t) {
  for (var r = e.length; r--; )
    if (Fn(e[r][0], t))
      return r;
  return -1;
}
var Pe = zn, Kn = Pe, Hn = Array.prototype, Bn = Hn.splice;
function Un(e) {
  var t = this.__data__, r = Kn(t, e);
  if (r < 0)
    return !1;
  var n = t.length - 1;
  return r == n ? t.pop() : Bn.call(t, r, 1), --this.size, !0;
}
var Wn = Un, Gn = Pe;
function qn(e) {
  var t = this.__data__, r = Gn(t, e);
  return r < 0 ? void 0 : t[r][1];
}
var Qn = qn, Jn = Pe;
function Vn(e) {
  return Jn(this.__data__, e) > -1;
}
var Yn = Vn, Xn = Pe;
function Zn(e, t) {
  var r = this.__data__, n = Xn(r, e);
  return n < 0 ? (++this.size, r.push([e, t])) : r[n][1] = t, this;
}
var ei = Zn, ti = Nn, ri = Wn, ni = Qn, ii = Yn, si = ei;
function we(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
we.prototype.clear = ti;
we.prototype.delete = ri;
we.prototype.get = ni;
we.prototype.has = ii;
we.prototype.set = si;
var ai = we, oi = kt, ci = Le, hi = oi(ci, "Map"), li = hi, lt = Ln, ui = ai, fi = li;
function di() {
  this.size = 0, this.__data__ = {
    hash: new lt(),
    map: new (fi || ui)(),
    string: new lt()
  };
}
var pi = di;
function gi(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
var _i = gi, mi = _i;
function yi(e, t) {
  var r = e.__data__;
  return mi(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
}
var Fe = yi, vi = Fe;
function bi(e) {
  var t = vi(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
var Ei = bi, Ci = Fe;
function xi(e) {
  return Ci(this, e).get(e);
}
var wi = xi, ki = Fe;
function Ii(e) {
  return ki(this, e).has(e);
}
var Oi = Ii, $i = Fe;
function Mi(e, t) {
  var r = $i(this, e), n = r.size;
  return r.set(e, t), this.size += r.size == n ? 0 : 1, this;
}
var Si = Mi, Ti = pi, Ai = Ei, Ri = wi, Li = Oi, ji = Si;
function ke(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
ke.prototype.clear = Ti;
ke.prototype.delete = Ai;
ke.prototype.get = Ri;
ke.prototype.has = Li;
ke.prototype.set = ji;
var Ni = ke, It = Ni, Di = "Expected a function";
function tt(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(Di);
  var r = function() {
    var n = arguments, a = t ? t.apply(this, n) : n[0], c = r.cache;
    if (c.has(a))
      return c.get(a);
    var h = e.apply(this, n);
    return r.cache = c.set(a, h) || c, h;
  };
  return r.cache = new (tt.Cache || It)(), r;
}
tt.Cache = It;
var Pi = tt, Fi = Pi, zi = 500;
function Ki(e) {
  var t = Fi(e, function(n) {
    return r.size === zi && r.clear(), n;
  }), r = t.cache;
  return t;
}
var Hi = Ki, Bi = Hi, Ui = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Wi = /\\(\\)?/g, Gi = Bi(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(Ui, function(r, n, a, c) {
    t.push(a ? c.replace(Wi, "$1") : n || r);
  }), t;
}), qi = Gi;
function Qi(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, a = Array(n); ++r < n; )
    a[r] = t(e[r], r, e);
  return a;
}
var Ji = Qi, ut = et, Vi = Ji, Yi = Ze, Xi = je, Zi = 1 / 0, ft = ut ? ut.prototype : void 0, dt = ft ? ft.toString : void 0;
function Ot(e) {
  if (typeof e == "string")
    return e;
  if (Yi(e))
    return Vi(e, Ot) + "";
  if (Xi(e))
    return dt ? dt.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -Zi ? "-0" : t;
}
var es = Ot, ts = es;
function rs(e) {
  return e == null ? "" : ts(e);
}
var ns = rs, is = Ze, ss = wr, as = qi, os = ns;
function cs(e, t) {
  return is(e) ? e : ss(e, t) ? [e] : as(os(e));
}
var hs = cs, ls = je, us = 1 / 0;
function fs(e) {
  if (typeof e == "string" || ls(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -us ? "-0" : t;
}
var ds = fs, ps = hs, gs = ds;
function _s(e, t) {
  t = ps(t, e);
  for (var r = 0, n = t.length; e != null && r < n; )
    e = e[gs(t[r++])];
  return r && r == n ? e : void 0;
}
var ms = _s, ys = ms;
function vs(e, t, r) {
  var n = e == null ? void 0 : ys(e, t);
  return n === void 0 ? r : n;
}
var Be = vs;
const $t = (e, t = {}, r = {}) => {
  const { autoPickAllColumns: n } = t;
  for (const a of e) {
    const { children: c } = a;
    c && (r = $t(c, t, r));
    const { title: h, key: l, dataIndex: o, exporter: f } = a, d = (Array.isArray(o) ? o.join(".") : o) ?? (l == null ? void 0 : l.toString());
    if (!d)
      continue;
    const p = d, E = typeof h == "string" ? h : p ?? "No Title";
    if (f) {
      const x = {
        header: E,
        formatter: typeof f == "function" ? f : f.formatter
      };
      r[p] = x;
      continue;
    }
    n && (r[p] = E);
  }
  return r;
}, bs = (e, t, r) => {
  if (!e || e.length === 0)
    return { data: [], fields: [] };
  const n = [...e], a = r.map((h) => {
    const l = Be(t, h);
    return typeof l == "string" || typeof l == "number" ? l : l.header || "";
  }), c = n.map((h, l) => r.map((o) => {
    var p;
    const f = Be(t, o), d = Be(h, o);
    return typeof f == "string" || typeof f == "number" ? d : (p = f == null ? void 0 : f.formatter) == null ? void 0 : p.call(f, d, h, l);
  }));
  return [a, ...c];
}, Es = (e) => {
  const {
    dataSource: t = [],
    fileName: r,
    fields: n,
    disabled: a,
    btnProps: c,
    modalProps: h,
    columns: l = [],
    showColumnPicker: o = !1,
    papaparseConfig: f = {},
    autoPickAllColumns: d = !0
  } = e, p = Te(
    () => $t(l, { ...e, autoPickAllColumns: d }),
    [d, l, e]
  ), [E, x] = re.useState(!1), O = Te(
    () => n ?? p,
    [p, n]
  ), [A, T] = re.useState(() => n ? Object.keys(n) : l ? Object.keys(p) : []);
  Ae(() => {
    n ? T(Object.keys(n)) : l && T(Object.keys(p));
  }, [n, l, p]);
  const M = re.useCallback(() => {
    if (!t)
      return;
    const j = Object.keys(O).filter(
      (s) => A.indexOf(s) > -1
    );
    console.log("fieldsOrColumns:", O);
    const B = bs(
      t,
      O,
      j
    );
    console.log("data:", B);
    const Q = Ge.unparse(B, {
      skipEmptyLines: "greedy",
      header: !1,
      ...f
    }), $ = new Blob([Q]), v = window.document.createElement("a");
    v.href = window.URL.createObjectURL($), v.download = `${r || "table"}.csv`, document.body.appendChild(v), v.click(), document.body.removeChild(v), x(!1);
  }, [t, O, f, r, A]), G = re.useCallback(
    (j, B) => {
      let Q = [...A];
      B ? Q = Array.from(/* @__PURE__ */ new Set([...Q, j])) : Q = Q.filter(($) => $ !== j), T(Q);
    },
    [A]
  );
  return /* @__PURE__ */ re.createElement(Ft, null, /* @__PURE__ */ re.createElement(
    zt,
    {
      onClick: () => o ? x(!0) : M(),
      disabled: a,
      ...c
    },
    e.children ?? "Export to CSV"
  ), o ? /* @__PURE__ */ re.createElement(
    Kt,
    {
      visible: E,
      onOk: () => M(),
      onCancel: () => x(!1),
      width: 400,
      okButtonProps: {
        disabled: A.length < 1,
        title: A.length < 1 ? "Please select at least one column." : void 0
      },
      okText: "Export",
      title: "Select columns to export",
      ...h
    },
    /* @__PURE__ */ re.createElement("div", { className: "d-flex flex-column align-start" }, Object.entries(O).map(([j, B]) => /* @__PURE__ */ re.createElement(
      Ht,
      {
        key: j,
        style: { padding: 0, margin: 0 },
        defaultChecked: !0,
        checked: A.indexOf(j) > -1,
        onChange: (Q) => G(j, Q.target.checked)
      },
      typeof B == "string" || typeof B == "number" ? B : (B == null ? void 0 : B.header) ?? ""
    )))
  ) : null);
};
var Cs = Le, xs = function() {
  return Cs.Date.now();
}, ws = xs, ks = /\s/;
function Is(e) {
  for (var t = e.length; t-- && ks.test(e.charAt(t)); )
    ;
  return t;
}
var Os = Is, $s = Os, Ms = /^\s+/;
function Ss(e) {
  return e && e.slice(0, $s(e) + 1).replace(Ms, "");
}
var Ts = Ss, As = Ts, pt = Ne, Rs = je, gt = 0 / 0, Ls = /^[-+]0x[0-9a-f]+$/i, js = /^0b[01]+$/i, Ns = /^0o[0-7]+$/i, Ds = parseInt;
function Ps(e) {
  if (typeof e == "number")
    return e;
  if (Rs(e))
    return gt;
  if (pt(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = pt(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = As(e);
  var r = js.test(e);
  return r || Ns.test(e) ? Ds(e.slice(2), r ? 2 : 8) : Ls.test(e) ? gt : +e;
}
var Fs = Ps, zs = Ne, Ue = ws, _t = Fs, Ks = "Expected a function", Hs = Math.max, Bs = Math.min;
function Us(e, t, r) {
  var n, a, c, h, l, o, f = 0, d = !1, p = !1, E = !0;
  if (typeof e != "function")
    throw new TypeError(Ks);
  t = _t(t) || 0, zs(r) && (d = !!r.leading, p = "maxWait" in r, c = p ? Hs(_t(r.maxWait) || 0, t) : c, E = "trailing" in r ? !!r.trailing : E);
  function x($) {
    var v = n, s = a;
    return n = a = void 0, f = $, h = e.apply(s, v), h;
  }
  function O($) {
    return f = $, l = setTimeout(M, t), d ? x($) : h;
  }
  function A($) {
    var v = $ - o, s = $ - f, i = t - v;
    return p ? Bs(i, c - s) : i;
  }
  function T($) {
    var v = $ - o, s = $ - f;
    return o === void 0 || v >= t || v < 0 || p && s >= c;
  }
  function M() {
    var $ = Ue();
    if (T($))
      return G($);
    l = setTimeout(M, A($));
  }
  function G($) {
    return l = void 0, E && n ? x($) : (n = a = void 0, h);
  }
  function j() {
    l !== void 0 && clearTimeout(l), f = 0, n = o = a = l = void 0;
  }
  function B() {
    return l === void 0 ? h : G(Ue());
  }
  function Q() {
    var $ = Ue(), v = T($);
    if (n = arguments, a = this, o = $, v) {
      if (l === void 0)
        return O(o);
      if (p)
        return clearTimeout(l), l = setTimeout(M, t), x(o);
    }
    return l === void 0 && (l = setTimeout(M, t)), h;
  }
  return Q.cancel = j, Q.flush = B, Q;
}
var Ws = Us;
function pe(e) {
  return Array.isArray ? Array.isArray(e) : Tt(e) === "[object Array]";
}
const Gs = 1 / 0;
function qs(e) {
  if (typeof e == "string")
    return e;
  let t = e + "";
  return t == "0" && 1 / e == -Gs ? "-0" : t;
}
function Qs(e) {
  return e == null ? "" : qs(e);
}
function ue(e) {
  return typeof e == "string";
}
function Mt(e) {
  return typeof e == "number";
}
function Js(e) {
  return e === !0 || e === !1 || Vs(e) && Tt(e) == "[object Boolean]";
}
function St(e) {
  return typeof e == "object";
}
function Vs(e) {
  return St(e) && e !== null;
}
function ne(e) {
  return e != null;
}
function We(e) {
  return !e.trim().length;
}
function Tt(e) {
  return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e);
}
const Ys = "Incorrect 'index' type", Xs = (e) => `Invalid value for key ${e}`, Zs = (e) => `Pattern length exceeds max of ${e}.`, ea = (e) => `Missing ${e} property in key`, ta = (e) => `Property 'weight' in key '${e}' must be a positive integer`, mt = Object.prototype.hasOwnProperty;
class ra {
  constructor(t) {
    this._keys = [], this._keyMap = {};
    let r = 0;
    t.forEach((n) => {
      let a = At(n);
      r += a.weight, this._keys.push(a), this._keyMap[a.id] = a, r += a.weight;
    }), this._keys.forEach((n) => {
      n.weight /= r;
    });
  }
  get(t) {
    return this._keyMap[t];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function At(e) {
  let t = null, r = null, n = null, a = 1, c = null;
  if (ue(e) || pe(e))
    n = e, t = yt(e), r = qe(e);
  else {
    if (!mt.call(e, "name"))
      throw new Error(ea("name"));
    const h = e.name;
    if (n = h, mt.call(e, "weight") && (a = e.weight, a <= 0))
      throw new Error(ta(h));
    t = yt(h), r = qe(h), c = e.getFn;
  }
  return { path: t, id: r, weight: a, src: n, getFn: c };
}
function yt(e) {
  return pe(e) ? e : e.split(".");
}
function qe(e) {
  return pe(e) ? e.join(".") : e;
}
function na(e, t) {
  let r = [], n = !1;
  const a = (c, h, l) => {
    if (ne(c))
      if (!h[l])
        r.push(c);
      else {
        let o = h[l];
        const f = c[o];
        if (!ne(f))
          return;
        if (l === h.length - 1 && (ue(f) || Mt(f) || Js(f)))
          r.push(Qs(f));
        else if (pe(f)) {
          n = !0;
          for (let d = 0, p = f.length; d < p; d += 1)
            a(f[d], h, l + 1);
        } else
          h.length && a(f, h, l + 1);
      }
  };
  return a(e, ue(t) ? t.split(".") : t, 0), n ? r : r[0];
}
const ia = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: !1,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: !1,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
}, sa = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: !1,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: !1,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: !0,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (e, t) => e.score === t.score ? e.idx < t.idx ? -1 : 1 : e.score < t.score ? -1 : 1
}, aa = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
}, oa = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: !1,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: na,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: !1,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: !1,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var I = {
  ...sa,
  ...ia,
  ...aa,
  ...oa
};
const ca = /[^ ]+/g;
function ha(e = 1, t = 3) {
  const r = /* @__PURE__ */ new Map(), n = Math.pow(10, t);
  return {
    get(a) {
      const c = a.match(ca).length;
      if (r.has(c))
        return r.get(c);
      const h = 1 / Math.pow(c, 0.5 * e), l = parseFloat(Math.round(h * n) / n);
      return r.set(c, l), l;
    },
    clear() {
      r.clear();
    }
  };
}
class rt {
  constructor({
    getFn: t = I.getFn,
    fieldNormWeight: r = I.fieldNormWeight
  } = {}) {
    this.norm = ha(r, 3), this.getFn = t, this.isCreated = !1, this.setIndexRecords();
  }
  setSources(t = []) {
    this.docs = t;
  }
  setIndexRecords(t = []) {
    this.records = t;
  }
  setKeys(t = []) {
    this.keys = t, this._keysMap = {}, t.forEach((r, n) => {
      this._keysMap[r.id] = n;
    });
  }
  create() {
    this.isCreated || !this.docs.length || (this.isCreated = !0, ue(this.docs[0]) ? this.docs.forEach((t, r) => {
      this._addString(t, r);
    }) : this.docs.forEach((t, r) => {
      this._addObject(t, r);
    }), this.norm.clear());
  }
  // Adds a doc to the end of the index
  add(t) {
    const r = this.size();
    ue(t) ? this._addString(t, r) : this._addObject(t, r);
  }
  // Removes the doc at the specified index of the index
  removeAt(t) {
    this.records.splice(t, 1);
    for (let r = t, n = this.size(); r < n; r += 1)
      this.records[r].i -= 1;
  }
  getValueForItemAtKeyId(t, r) {
    return t[this._keysMap[r]];
  }
  size() {
    return this.records.length;
  }
  _addString(t, r) {
    if (!ne(t) || We(t))
      return;
    let n = {
      v: t,
      i: r,
      n: this.norm.get(t)
    };
    this.records.push(n);
  }
  _addObject(t, r) {
    let n = { i: r, $: {} };
    this.keys.forEach((a, c) => {
      let h = a.getFn ? a.getFn(t) : this.getFn(t, a.path);
      if (ne(h)) {
        if (pe(h)) {
          let l = [];
          const o = [{ nestedArrIndex: -1, value: h }];
          for (; o.length; ) {
            const { nestedArrIndex: f, value: d } = o.pop();
            if (ne(d))
              if (ue(d) && !We(d)) {
                let p = {
                  v: d,
                  i: f,
                  n: this.norm.get(d)
                };
                l.push(p);
              } else
                pe(d) && d.forEach((p, E) => {
                  o.push({
                    nestedArrIndex: E,
                    value: p
                  });
                });
          }
          n.$[c] = l;
        } else if (ue(h) && !We(h)) {
          let l = {
            v: h,
            n: this.norm.get(h)
          };
          n.$[c] = l;
        }
      }
    }), this.records.push(n);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function Rt(e, t, { getFn: r = I.getFn, fieldNormWeight: n = I.fieldNormWeight } = {}) {
  const a = new rt({ getFn: r, fieldNormWeight: n });
  return a.setKeys(e.map(At)), a.setSources(t), a.create(), a;
}
function la(e, { getFn: t = I.getFn, fieldNormWeight: r = I.fieldNormWeight } = {}) {
  const { keys: n, records: a } = e, c = new rt({ getFn: t, fieldNormWeight: r });
  return c.setKeys(n), c.setIndexRecords(a), c;
}
function Se(e, {
  errors: t = 0,
  currentLocation: r = 0,
  expectedLocation: n = 0,
  distance: a = I.distance,
  ignoreLocation: c = I.ignoreLocation
} = {}) {
  const h = t / e.length;
  if (c)
    return h;
  const l = Math.abs(n - r);
  return a ? h + l / a : l ? 1 : h;
}
function ua(e = [], t = I.minMatchCharLength) {
  let r = [], n = -1, a = -1, c = 0;
  for (let h = e.length; c < h; c += 1) {
    let l = e[c];
    l && n === -1 ? n = c : !l && n !== -1 && (a = c - 1, a - n + 1 >= t && r.push([n, a]), n = -1);
  }
  return e[c - 1] && c - n >= t && r.push([n, c - 1]), r;
}
const Ee = 32;
function fa(e, t, r, {
  location: n = I.location,
  distance: a = I.distance,
  threshold: c = I.threshold,
  findAllMatches: h = I.findAllMatches,
  minMatchCharLength: l = I.minMatchCharLength,
  includeMatches: o = I.includeMatches,
  ignoreLocation: f = I.ignoreLocation
} = {}) {
  if (t.length > Ee)
    throw new Error(Zs(Ee));
  const d = t.length, p = e.length, E = Math.max(0, Math.min(n, p));
  let x = c, O = E;
  const A = l > 1 || o, T = A ? Array(p) : [];
  let M;
  for (; (M = e.indexOf(t, O)) > -1; ) {
    let v = Se(t, {
      currentLocation: M,
      expectedLocation: E,
      distance: a,
      ignoreLocation: f
    });
    if (x = Math.min(v, x), O = M + d, A) {
      let s = 0;
      for (; s < d; )
        T[M + s] = 1, s += 1;
    }
  }
  O = -1;
  let G = [], j = 1, B = d + p;
  const Q = 1 << d - 1;
  for (let v = 0; v < d; v += 1) {
    let s = 0, i = B;
    for (; s < i; )
      Se(t, {
        errors: v,
        currentLocation: E + i,
        expectedLocation: E,
        distance: a,
        ignoreLocation: f
      }) <= x ? s = i : B = i, i = Math.floor((B - s) / 2 + s);
    B = i;
    let u = Math.max(1, E - i + 1), g = h ? p : Math.min(E + i, p) + d, _ = Array(g + 2);
    _[g + 1] = (1 << v) - 1;
    for (let w = g; w >= u; w -= 1) {
      let K = w - 1, N = r[e.charAt(K)];
      if (A && (T[K] = +!!N), _[w] = (_[w + 1] << 1 | 1) & N, v && (_[w] |= (G[w + 1] | G[w]) << 1 | 1 | G[w + 1]), _[w] & Q && (j = Se(t, {
        errors: v,
        currentLocation: K,
        expectedLocation: E,
        distance: a,
        ignoreLocation: f
      }), j <= x)) {
        if (x = j, O = K, O <= E)
          break;
        u = Math.max(1, 2 * E - O);
      }
    }
    if (Se(t, {
      errors: v + 1,
      currentLocation: E,
      expectedLocation: E,
      distance: a,
      ignoreLocation: f
    }) > x)
      break;
    G = _;
  }
  const $ = {
    isMatch: O >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, j)
  };
  if (A) {
    const v = ua(T, l);
    v.length ? o && ($.indices = v) : $.isMatch = !1;
  }
  return $;
}
function da(e) {
  let t = {};
  for (let r = 0, n = e.length; r < n; r += 1) {
    const a = e.charAt(r);
    t[a] = (t[a] || 0) | 1 << n - r - 1;
  }
  return t;
}
class Lt {
  constructor(t, {
    location: r = I.location,
    threshold: n = I.threshold,
    distance: a = I.distance,
    includeMatches: c = I.includeMatches,
    findAllMatches: h = I.findAllMatches,
    minMatchCharLength: l = I.minMatchCharLength,
    isCaseSensitive: o = I.isCaseSensitive,
    ignoreLocation: f = I.ignoreLocation
  } = {}) {
    if (this.options = {
      location: r,
      threshold: n,
      distance: a,
      includeMatches: c,
      findAllMatches: h,
      minMatchCharLength: l,
      isCaseSensitive: o,
      ignoreLocation: f
    }, this.pattern = o ? t : t.toLowerCase(), this.chunks = [], !this.pattern.length)
      return;
    const d = (E, x) => {
      this.chunks.push({
        pattern: E,
        alphabet: da(E),
        startIndex: x
      });
    }, p = this.pattern.length;
    if (p > Ee) {
      let E = 0;
      const x = p % Ee, O = p - x;
      for (; E < O; )
        d(this.pattern.substr(E, Ee), E), E += Ee;
      if (x) {
        const A = p - Ee;
        d(this.pattern.substr(A), A);
      }
    } else
      d(this.pattern, 0);
  }
  searchIn(t) {
    const { isCaseSensitive: r, includeMatches: n } = this.options;
    if (r || (t = t.toLowerCase()), this.pattern === t) {
      let O = {
        isMatch: !0,
        score: 0
      };
      return n && (O.indices = [[0, t.length - 1]]), O;
    }
    const {
      location: a,
      distance: c,
      threshold: h,
      findAllMatches: l,
      minMatchCharLength: o,
      ignoreLocation: f
    } = this.options;
    let d = [], p = 0, E = !1;
    this.chunks.forEach(({ pattern: O, alphabet: A, startIndex: T }) => {
      const { isMatch: M, score: G, indices: j } = fa(t, O, A, {
        location: a + T,
        distance: c,
        threshold: h,
        findAllMatches: l,
        minMatchCharLength: o,
        includeMatches: n,
        ignoreLocation: f
      });
      M && (E = !0), p += G, M && j && (d = [...d, ...j]);
    });
    let x = {
      isMatch: E,
      score: E ? p / this.chunks.length : 1
    };
    return E && n && (x.indices = d), x;
  }
}
class ye {
  constructor(t) {
    this.pattern = t;
  }
  static isMultiMatch(t) {
    return vt(t, this.multiRegex);
  }
  static isSingleMatch(t) {
    return vt(t, this.singleRegex);
  }
  search() {
  }
}
function vt(e, t) {
  const r = e.match(t);
  return r ? r[1] : null;
}
class pa extends ye {
  constructor(t) {
    super(t);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(t) {
    const r = t === this.pattern;
    return {
      isMatch: r,
      score: r ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class ga extends ye {
  constructor(t) {
    super(t);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(t) {
    const n = t.indexOf(this.pattern) === -1;
    return {
      isMatch: n,
      score: n ? 0 : 1,
      indices: [0, t.length - 1]
    };
  }
}
class _a extends ye {
  constructor(t) {
    super(t);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(t) {
    const r = t.startsWith(this.pattern);
    return {
      isMatch: r,
      score: r ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class ma extends ye {
  constructor(t) {
    super(t);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(t) {
    const r = !t.startsWith(this.pattern);
    return {
      isMatch: r,
      score: r ? 0 : 1,
      indices: [0, t.length - 1]
    };
  }
}
class ya extends ye {
  constructor(t) {
    super(t);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(t) {
    const r = t.endsWith(this.pattern);
    return {
      isMatch: r,
      score: r ? 0 : 1,
      indices: [t.length - this.pattern.length, t.length - 1]
    };
  }
}
class va extends ye {
  constructor(t) {
    super(t);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(t) {
    const r = !t.endsWith(this.pattern);
    return {
      isMatch: r,
      score: r ? 0 : 1,
      indices: [0, t.length - 1]
    };
  }
}
class jt extends ye {
  constructor(t, {
    location: r = I.location,
    threshold: n = I.threshold,
    distance: a = I.distance,
    includeMatches: c = I.includeMatches,
    findAllMatches: h = I.findAllMatches,
    minMatchCharLength: l = I.minMatchCharLength,
    isCaseSensitive: o = I.isCaseSensitive,
    ignoreLocation: f = I.ignoreLocation
  } = {}) {
    super(t), this._bitapSearch = new Lt(t, {
      location: r,
      threshold: n,
      distance: a,
      includeMatches: c,
      findAllMatches: h,
      minMatchCharLength: l,
      isCaseSensitive: o,
      ignoreLocation: f
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(t) {
    return this._bitapSearch.searchIn(t);
  }
}
class Nt extends ye {
  constructor(t) {
    super(t);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(t) {
    let r = 0, n;
    const a = [], c = this.pattern.length;
    for (; (n = t.indexOf(this.pattern, r)) > -1; )
      r = n + c, a.push([n, r - 1]);
    const h = !!a.length;
    return {
      isMatch: h,
      score: h ? 0 : 1,
      indices: a
    };
  }
}
const Qe = [
  pa,
  Nt,
  _a,
  ma,
  va,
  ya,
  ga,
  jt
], bt = Qe.length, ba = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/, Ea = "|";
function Ca(e, t = {}) {
  return e.split(Ea).map((r) => {
    let n = r.trim().split(ba).filter((c) => c && !!c.trim()), a = [];
    for (let c = 0, h = n.length; c < h; c += 1) {
      const l = n[c];
      let o = !1, f = -1;
      for (; !o && ++f < bt; ) {
        const d = Qe[f];
        let p = d.isMultiMatch(l);
        p && (a.push(new d(p, t)), o = !0);
      }
      if (!o)
        for (f = -1; ++f < bt; ) {
          const d = Qe[f];
          let p = d.isSingleMatch(l);
          if (p) {
            a.push(new d(p, t));
            break;
          }
        }
    }
    return a;
  });
}
const xa = /* @__PURE__ */ new Set([jt.type, Nt.type]);
class wa {
  constructor(t, {
    isCaseSensitive: r = I.isCaseSensitive,
    includeMatches: n = I.includeMatches,
    minMatchCharLength: a = I.minMatchCharLength,
    ignoreLocation: c = I.ignoreLocation,
    findAllMatches: h = I.findAllMatches,
    location: l = I.location,
    threshold: o = I.threshold,
    distance: f = I.distance
  } = {}) {
    this.query = null, this.options = {
      isCaseSensitive: r,
      includeMatches: n,
      minMatchCharLength: a,
      findAllMatches: h,
      ignoreLocation: c,
      location: l,
      threshold: o,
      distance: f
    }, this.pattern = r ? t : t.toLowerCase(), this.query = Ca(this.pattern, this.options);
  }
  static condition(t, r) {
    return r.useExtendedSearch;
  }
  searchIn(t) {
    const r = this.query;
    if (!r)
      return {
        isMatch: !1,
        score: 1
      };
    const { includeMatches: n, isCaseSensitive: a } = this.options;
    t = a ? t : t.toLowerCase();
    let c = 0, h = [], l = 0;
    for (let o = 0, f = r.length; o < f; o += 1) {
      const d = r[o];
      h.length = 0, c = 0;
      for (let p = 0, E = d.length; p < E; p += 1) {
        const x = d[p], { isMatch: O, indices: A, score: T } = x.search(t);
        if (O) {
          if (c += 1, l += T, n) {
            const M = x.constructor.type;
            xa.has(M) ? h = [...h, ...A] : h.push(A);
          }
        } else {
          l = 0, c = 0, h.length = 0;
          break;
        }
      }
      if (c) {
        let p = {
          isMatch: !0,
          score: l / c
        };
        return n && (p.indices = h), p;
      }
    }
    return {
      isMatch: !1,
      score: 1
    };
  }
}
const Je = [];
function ka(...e) {
  Je.push(...e);
}
function Ve(e, t) {
  for (let r = 0, n = Je.length; r < n; r += 1) {
    let a = Je[r];
    if (a.condition(e, t))
      return new a(e, t);
  }
  return new Lt(e, t);
}
const Re = {
  AND: "$and",
  OR: "$or"
}, Ye = {
  PATH: "$path",
  PATTERN: "$val"
}, Xe = (e) => !!(e[Re.AND] || e[Re.OR]), Ia = (e) => !!e[Ye.PATH], Oa = (e) => !pe(e) && St(e) && !Xe(e), Et = (e) => ({
  [Re.AND]: Object.keys(e).map((t) => ({
    [t]: e[t]
  }))
});
function Dt(e, t, { auto: r = !0 } = {}) {
  const n = (a) => {
    let c = Object.keys(a);
    const h = Ia(a);
    if (!h && c.length > 1 && !Xe(a))
      return n(Et(a));
    if (Oa(a)) {
      const o = h ? a[Ye.PATH] : c[0], f = h ? a[Ye.PATTERN] : a[o];
      if (!ue(f))
        throw new Error(Xs(o));
      const d = {
        keyId: qe(o),
        pattern: f
      };
      return r && (d.searcher = Ve(f, t)), d;
    }
    let l = {
      children: [],
      operator: c[0]
    };
    return c.forEach((o) => {
      const f = a[o];
      pe(f) && f.forEach((d) => {
        l.children.push(n(d));
      });
    }), l;
  };
  return Xe(e) || (e = Et(e)), n(e);
}
function $a(e, { ignoreFieldNorm: t = I.ignoreFieldNorm }) {
  e.forEach((r) => {
    let n = 1;
    r.matches.forEach(({ key: a, norm: c, score: h }) => {
      const l = a ? a.weight : null;
      n *= Math.pow(
        h === 0 && l ? Number.EPSILON : h,
        (l || 1) * (t ? 1 : c)
      );
    }), r.score = n;
  });
}
function Ma(e, t) {
  const r = e.matches;
  t.matches = [], ne(r) && r.forEach((n) => {
    if (!ne(n.indices) || !n.indices.length)
      return;
    const { indices: a, value: c } = n;
    let h = {
      indices: a,
      value: c
    };
    n.key && (h.key = n.key.src), n.idx > -1 && (h.refIndex = n.idx), t.matches.push(h);
  });
}
function Sa(e, t) {
  t.score = e.score;
}
function Ta(e, t, {
  includeMatches: r = I.includeMatches,
  includeScore: n = I.includeScore
} = {}) {
  const a = [];
  return r && a.push(Ma), n && a.push(Sa), e.map((c) => {
    const { idx: h } = c, l = {
      item: t[h],
      refIndex: h
    };
    return a.length && a.forEach((o) => {
      o(c, l);
    }), l;
  });
}
class Ie {
  constructor(t, r = {}, n) {
    this.options = { ...I, ...r }, this.options.useExtendedSearch, this._keyStore = new ra(this.options.keys), this.setCollection(t, n);
  }
  setCollection(t, r) {
    if (this._docs = t, r && !(r instanceof rt))
      throw new Error(Ys);
    this._myIndex = r || Rt(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(t) {
    ne(t) && (this._docs.push(t), this._myIndex.add(t));
  }
  remove(t = () => !1) {
    const r = [];
    for (let n = 0, a = this._docs.length; n < a; n += 1) {
      const c = this._docs[n];
      t(c, n) && (this.removeAt(n), n -= 1, a -= 1, r.push(c));
    }
    return r;
  }
  removeAt(t) {
    this._docs.splice(t, 1), this._myIndex.removeAt(t);
  }
  getIndex() {
    return this._myIndex;
  }
  search(t, { limit: r = -1 } = {}) {
    const {
      includeMatches: n,
      includeScore: a,
      shouldSort: c,
      sortFn: h,
      ignoreFieldNorm: l
    } = this.options;
    let o = ue(t) ? ue(this._docs[0]) ? this._searchStringList(t) : this._searchObjectList(t) : this._searchLogical(t);
    return $a(o, { ignoreFieldNorm: l }), c && o.sort(h), Mt(r) && r > -1 && (o = o.slice(0, r)), Ta(o, this._docs, {
      includeMatches: n,
      includeScore: a
    });
  }
  _searchStringList(t) {
    const r = Ve(t, this.options), { records: n } = this._myIndex, a = [];
    return n.forEach(({ v: c, i: h, n: l }) => {
      if (!ne(c))
        return;
      const { isMatch: o, score: f, indices: d } = r.searchIn(c);
      o && a.push({
        item: c,
        idx: h,
        matches: [{ score: f, value: c, norm: l, indices: d }]
      });
    }), a;
  }
  _searchLogical(t) {
    const r = Dt(t, this.options), n = (l, o, f) => {
      if (!l.children) {
        const { keyId: p, searcher: E } = l, x = this._findMatches({
          key: this._keyStore.get(p),
          value: this._myIndex.getValueForItemAtKeyId(o, p),
          searcher: E
        });
        return x && x.length ? [
          {
            idx: f,
            item: o,
            matches: x
          }
        ] : [];
      }
      const d = [];
      for (let p = 0, E = l.children.length; p < E; p += 1) {
        const x = l.children[p], O = n(x, o, f);
        if (O.length)
          d.push(...O);
        else if (l.operator === Re.AND)
          return [];
      }
      return d;
    }, a = this._myIndex.records, c = {}, h = [];
    return a.forEach(({ $: l, i: o }) => {
      if (ne(l)) {
        let f = n(r, l, o);
        f.length && (c[o] || (c[o] = { idx: o, item: l, matches: [] }, h.push(c[o])), f.forEach(({ matches: d }) => {
          c[o].matches.push(...d);
        }));
      }
    }), h;
  }
  _searchObjectList(t) {
    const r = Ve(t, this.options), { keys: n, records: a } = this._myIndex, c = [];
    return a.forEach(({ $: h, i: l }) => {
      if (!ne(h))
        return;
      let o = [];
      n.forEach((f, d) => {
        o.push(
          ...this._findMatches({
            key: f,
            value: h[d],
            searcher: r
          })
        );
      }), o.length && c.push({
        idx: l,
        item: h,
        matches: o
      });
    }), c;
  }
  _findMatches({ key: t, value: r, searcher: n }) {
    if (!ne(r))
      return [];
    let a = [];
    if (pe(r))
      r.forEach(({ v: c, i: h, n: l }) => {
        if (!ne(c))
          return;
        const { isMatch: o, score: f, indices: d } = n.searchIn(c);
        o && a.push({
          score: f,
          key: t,
          value: c,
          idx: h,
          norm: l,
          indices: d
        });
      });
    else {
      const { v: c, n: h } = r, { isMatch: l, score: o, indices: f } = n.searchIn(c);
      l && a.push({ score: o, key: t, value: c, norm: h, indices: f });
    }
    return a;
  }
}
Ie.version = "6.6.2";
Ie.createIndex = Rt;
Ie.parseIndex = la;
Ie.config = I;
Ie.parseQuery = Dt;
ka(wa);
const Pt = (e, t = []) => {
  for (const r of e.children) {
    const n = r;
    if (n.children && Array.isArray(n.children))
      t = Pt(n, t);
    else {
      const a = r;
      if (!a.dataIndex)
        continue;
      if (Array.isArray(a.dataIndex)) {
        t = [...t, a.dataIndex.join(".")];
        continue;
      }
      t = [...t, a.dataIndex];
    }
  }
  return t;
}, Aa = (e, t) => {
  const r = e == null ? void 0 : e[0];
  return (t ?? []).map((a) => {
    const { children: c } = a;
    if (c && Array.isArray(c))
      return (Pt(
        a,
        []
      ) ?? []).flat();
    const { dataIndex: h } = a;
    if (Array.isArray(h))
      return h.join(".");
    if (r && Object.prototype.toString.call(r[h]) === "[object Object]" && ["string", "number"].includes(typeof h))
      throw new Error(
        `'${h}' is an object in dataSource. But dataIndex is given as string. If it is an object, use array of strings as dataIndex.`
      );
    return h;
  }).filter((a) => !!a).flat(10).filter((a) => ["string", "number"].includes(typeof a));
};
function Ra({
  searchFunction: e = void 0,
  dataSource: t = [],
  setDataSource: r,
  debounce: n = !0,
  inputProps: a = {
    placeholder: "Search..."
  },
  fuzzySearch: c = !1,
  columns: h = [],
  fuseProps: l
}) {
  const [o, f] = Ct(""), d = it([]), p = it(), E = re.useMemo(() => ({
    keys: Aa(t, h),
    threshold: c ? 0.6 : 0.1,
    shouldSort: !1,
    ...l
  }), [l, t, h, c]), x = Ke(
    (T, M = "") => M === "" || !p || !p.current ? d.current ?? [] : p.current.search(M).map((j) => j.item),
    []
  ), O = Ke(
    Ws(
      (T, M, G) => {
        const j = G == null ? void 0 : G(T, M);
        r == null || r(j);
      },
      100,
      {
        leading: !1,
        trailing: !0
      }
    ),
    []
  ), A = Ke(
    (T) => {
      const M = T.target.value;
      if (f(M), n)
        O(t, M, e ?? x);
      else {
        const G = (e == null ? void 0 : e(t, M)) ?? x(t, M);
        r == null || r(G);
      }
    },
    [
      t,
      n,
      e,
      x,
      O,
      r
    ]
  );
  return Ae(() => {
    t && (d.current = [...t], p.current = new Ie(t, E));
  }, [t, E]), Ae(() => {
    if (!(!t || !o))
      if (n)
        O(t, o, e ?? x);
      else {
        const T = (e == null ? void 0 : e(t, o)) ?? x(t, o);
        r == null || r(T);
      }
  }, [
    o,
    t,
    O,
    e,
    r,
    n,
    x
  ]), /* @__PURE__ */ re.createElement(
    Bt,
    {
      value: o,
      onChange: A,
      placeholder: "Search...",
      allowClear: !0,
      ...a
    }
  );
}
function Na({
  exportable: e = !1,
  exportableProps: t,
  searchable: r = !1,
  searchableProps: n,
  dataSource: a,
  columns: c,
  ...h
}) {
  var p;
  const l = Te(
    () => e || !!t,
    [e, t]
  ), o = Te(
    () => r || n,
    [r, n]
  ), [f, d] = Ct(a);
  return Ae(() => {
    o && d(a);
  }, [a, o]), /* @__PURE__ */ re.createElement("div", { className: "ant-table-extensions" }, /* @__PURE__ */ re.createElement(
    "div",
    {
      style: {
        display: "flex",
        justifyContent: "space-between",
        marginBottom: 10
      }
    },
    l ? /* @__PURE__ */ re.createElement(
      Es,
      {
        dataSource: a,
        columns: c,
        ...t
      }
    ) : null,
    o ? /* @__PURE__ */ re.createElement(
      Ra,
      {
        columns: c,
        dataSource: a,
        setDataSource: d,
        ...n,
        inputProps: {
          style: {
            width: l ? "60%" : "100%",
            ...(p = n == null ? void 0 : n.inputProps) == null ? void 0 : p.style
          },
          ...n == null ? void 0 : n.inputProps
        }
      }
    ) : null
  ), /* @__PURE__ */ re.createElement(
    Ut,
    {
      dataSource: o ? f : a,
      columns: c,
      ...h
    }
  ));
}
export {
  Es as ExportTableButton,
  Ra as SearchTableInput,
  Na as Table
};
